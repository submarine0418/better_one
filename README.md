æ²’å•é¡Œï¼Œæˆ‘å€‘ç¾åœ¨æ‹¿è‘—æ”¾å¤§é¡ï¼Œä¸€è¡Œä¸€è¡Œä¾†çœ‹é€™äº›ã€Œé­”é¬¼ç´°ç¯€ã€ã€‚æˆ‘æœƒæŠŠç¨‹å¼ç¢¼æ‹†è§£æˆå¹¾å€‹é—œéµçš„æŠ€è¡“é»ï¼Œå‘Šè¨´ä½ ç‚ºä»€éº¼è¦é€™æ¨£å¯«ï¼Œä»¥åŠé€™äº›å¯«æ³•èƒŒå¾Œçš„ã€Œçœ‰è§’ã€ã€‚

é€™ä»½ç¨‹å¼ç¢¼çš„æŠ€è¡“å«é‡‘é‡å…¶å¯¦å¾ˆé«˜ï¼Œä¸»è¦é›†ä¸­åœ¨ä»¥ä¸‹å››å€‹ç´°ç¯€ï¼š

---

### 1. GPU åŠ é€Ÿçš„è‰²å½©è½‰æ› (`RGB2Lab_GPU`)

é€™æ®µç¨‹å¼ç¢¼æ˜¯ç‚ºäº†å–ä»£ `skimage.color.rgb2lab`ã€‚ç‚ºä»€éº¼è¦è‡ªå·±å¯«ï¼Ÿå› ç‚º `skimage` æ˜¯ CPU é‹ç®—ï¼Œè€Œä¸”ç„¡æ³•å¾®åˆ†ï¼ˆä¸èƒ½åå‘å‚³æ’­ï¼‰ã€‚

```python
class RGB2Lab_GPU(nn.Module):
    def __init__(self):
        super().__init__()
        # é€™è£¡ç”¨ register_buffer è€Œä¸æ˜¯ self.matrix = ...
        # åŸå› ï¼šbuffer æœƒè¢«è¦–ç‚ºæ¨¡å‹çš„ä¸€éƒ¨åˆ†ï¼Œè·Ÿè‘—æ¨¡å‹ä¸€èµ· .to(device) ç§»å‹•åˆ° GPUï¼Œ
        # ä½†å®ƒä¸æ˜¯ Parameterï¼Œæ‰€ä»¥ä¸æœƒè¢«å„ªåŒ–å™¨æ›´æ–°ï¼ˆæˆ‘å€‘ä¸å¸Œæœ›æ”¹è®Šç‰©ç†å…¬å¼ï¼‰ã€‚
        self.register_buffer('matrix_srgb2xyz', torch.tensor([
            [0.4124564, 0.3575761, 0.1804375],
            ...
        ], dtype=torch.float32))
        # ...

    def forward(self, rgb):
        # 1. Gamma æ ¡æ­£ (sRGB -> Linear RGB)
        # é€™æ˜¯è‰²å½©å­¸çš„æ¨™æº–å…¬å¼ã€‚sRGB åœ–ç‰‡æ˜¯ç‚ºäº†è®“äººçœ¼çœ‹è‘—èˆ’æœï¼Œç¶“éäº† Gamma å£“ç¸®ã€‚
        # è¦åšæ•¸å­¸é‹ç®—ï¼ˆè½‰ XYZï¼‰ï¼Œå¿…é ˆå…ˆé‚„åŸæˆç·šæ€§å…‰ã€‚
        mask = rgb > 0.04045
        rgb_linear = torch.where(mask, torch.pow((rgb + 0.055) / 1.055, 2.4), rgb / 12.92)
        
        # 2. çŸ©é™£ä¹˜æ³• (Linear RGB -> XYZ)
        # é€™è£¡ç”¨äº† torch.matmulï¼Œé€™æ˜¯ GPU çš„å¼·é …ã€‚
        # permute(0, 2, 3, 1) æ˜¯æŠŠ (Batch, Channel, H, W) è½‰æˆ (Batch, H, W, Channel)
        # å› ç‚ºçŸ©é™£ä¹˜æ³•é€šå¸¸æ˜¯å°æœ€å¾Œä¸€å€‹ç¶­åº¦æ“ä½œã€‚
        xyz = torch.matmul(rgb_linear.permute(0, 2, 3, 1), self.matrix_srgb2xyz.t())
        
        # ... (å¾ŒçºŒ XYZ -> LAB çš„éç·šæ€§è½‰æ›)
```

**ç´°ç¯€é‡é»ï¼š**
*   **`register_buffer`**ï¼šç¢ºä¿å¸¸æ•¸çŸ©é™£è‡ªå‹•è·Ÿè‘— GPU è·‘ã€‚
*   **`torch.where`**ï¼šé€™æ˜¯ GPU ç‰ˆçš„ `if-else`ï¼Œå¯ä»¥åŒæ™‚è™•ç†å¹¾ç™¾è¬å€‹åƒç´ çš„æ¢ä»¶åˆ¤æ–·ã€‚

---

### 2. å‡çµé è¨“ç·´æ¨¡å‹ (`MATLABStyleTrainer.__init__`)

æˆ‘å€‘è¼‰å…¥äº†å…©å€‹å·²ç¶“è¨“ç·´å¥½çš„æ¨¡å‹ï¼ˆè‰²å½©æ ¡æ­£ã€å¤§æ°£å…‰ï¼‰ï¼Œä½†æˆ‘å€‘ä¸æƒ³å‹•å®ƒå€‘ã€‚

```python
        # 1. è¼‰å…¥æ¨¡å‹
        self.color_net = LightweightColorCorrectionNet(base_channels=16).to(device)
        ckpt_color = torch.load(..., map_location=device)
        self.color_net.load_state_dict(ckpt_color['model_state_dict'])
        
        # 2. è¨­å®šç‚ºè©•ä¼°æ¨¡å¼
        self.color_net.eval() 
        
        # 3. é—œé–‰æ¢¯åº¦è¨ˆç®— (é—œéµç´°ç¯€ï¼)
        for p in self.color_net.parameters(): 
            p.requires_grad = False
```

**ç´°ç¯€é‡é»ï¼š**
*   **`eval()`**ï¼šå‘Šè¨´æ¨¡å‹ç¾åœ¨æ˜¯æ¨ç†æ¨¡å¼ï¼Œé€™æœƒå½±éŸ¿ `BatchNorm` å’Œ `Dropout` çš„è¡Œç‚ºï¼ˆè®“çµæœç©©å®šï¼‰ã€‚
*   **`requires_grad = False`**ï¼šé€™å‘Šè¨´ PyTorchï¼šã€Œä¸è¦æµªè²»è¨˜æ†¶é«”å»ç´€éŒ„é€™äº›åƒæ•¸çš„æ¢¯åº¦ï¼Œåæ­£æˆ‘ä¸æœƒæ›´æ–°å®ƒå€‘ã€ã€‚é€™èƒ½å¤§å¹…ç¯€çœé¡¯å¡è¨˜æ†¶é«” (VRAM)ã€‚

---

### 3. æ··åˆç²¾åº¦è¨“ç·´ (`use_amp`)

é€™æ˜¯ç¾ä»£æ·±åº¦å­¸ç¿’åŠ é€Ÿçš„ç¥å™¨ã€‚

```python
        # åˆå§‹åŒ– Scaler
        if self.use_amp:
            self.scaler = torch.amp.GradScaler('cuda')

        # è¨“ç·´è¿´åœˆå…§
        if self.use_amp:
            # é–‹å•Ÿè‡ªå‹•æ··åˆç²¾åº¦ç’°å¢ƒ
            with torch.amp.autocast('cuda'):
                # é€™è£¡é¢çš„é‹ç®—æœƒè‡ªå‹•åˆ‡æ›ç²¾åº¦ï¼š
                # å·ç©ã€çŸ©é™£ä¹˜æ³• -> float16 (åŠç²¾åº¦ï¼Œå¿«ï¼Œçœè¨˜æ†¶é«”)
                # Loss è¨ˆç®—ã€Softmax -> float32 (å–®ç²¾åº¦ï¼Œæº–ç¢º)
                params = self.param_predictor(images_vgg, features)
                enhanced, _ = self.enhancement(...)
                loss, components = self.criterion(...)
            
            # Scaler çš„ä½œç”¨ï¼š
            # å› ç‚º float16 ç¯„åœå°ï¼Œæ¢¯åº¦å¯èƒ½æœƒè®Šæˆ 0 (Underflow)ã€‚
            # Scaler æœƒå…ˆæŠŠ Loss æ”¾å¤§ (Scale)ï¼Œç®—å®Œæ¢¯åº¦å¾Œå†ç¸®å°å›ä¾† (Unscale)ã€‚
            self.scaler.scale(loss).backward()
            self.scaler.unscale_(self.optimizer)
            torch.nn.utils.clip_grad_norm_(...) # æ¢¯åº¦è£å‰ª
            self.scaler.step(self.optimizer)
            self.scaler.update()
```

**ç´°ç¯€é‡é»ï¼š**
*   **`float16` vs `float32`**ï¼š`float16` é‹ç®—é€Ÿåº¦å¿«ï¼Œä¸”ä½”ç”¨è¨˜æ†¶é«”æ¸›åŠï¼Œå¯ä»¥è®“ä½ é–‹æ›´å¤§çš„ Batch Sizeã€‚
*   **`GradScaler`**ï¼šé˜²æ­¢æ¢¯åº¦æ¶ˆå¤±çš„ä¿éšªæ©Ÿåˆ¶ã€‚

---

### 4. æå¤±å‡½æ•¸çš„è¨­è¨ˆ (`FullSSIMCombinedLoss`)

ç‚ºä»€éº¼ä¸åªç”¨ MSE (å‡æ–¹èª¤å·®)ï¼Ÿ

```python
class FullSSIMCombinedLoss(nn.Module):
    def __init__(self, ssim_weight=0.8, l1_weight=0.2, ...):
        # ...
    
    def forward(self, enhanced, reference):
        # SSIM (çµæ§‹ç›¸ä¼¼æ€§)ï¼šçœ‹åœ–ç‰‡ã€Œç³Šä¸ç³Šã€ã€ã€Œçµæ§‹å°ä¸å°ã€
        ssim = self.ssim_loss(enhanced, reference)
        
        # L1 Loss (çµ•å°å€¼èª¤å·®)ï¼šçœ‹é¡è‰²æ•¸å€¼ã€Œæº–ä¸æº–ã€
        # ç‚ºä»€éº¼ç”¨ L1 ä¸ç”¨ MSE (L2)ï¼Ÿ
        # å› ç‚º MSE æœƒæ”¾å¤§ç•°å¸¸å€¼ï¼Œå°è‡´ç”Ÿæˆçš„åœ–ç‰‡è®Šæ¨¡ç³Šï¼›L1 ç”¢ç”Ÿçš„åœ–ç‰‡æ¯”è¼ƒéŠ³åˆ©ã€‚
        l1 = self.l1_loss(enhanced, reference)
        
        # åŠ æ¬Šç¸½å’Œ
        total_loss = (self.ssim_weight * ssim + self.l1_weight * l1)
```

**ç´°ç¯€é‡é»ï¼š**
*   **æ¬Šé‡åˆ†é…**ï¼š`0.8 * SSIM` è¡¨ç¤ºæˆ‘å€‘æ›´åœ¨æ„çµæ§‹æ¸…æ™°åº¦ï¼Œ`0.2 * L1` è¡¨ç¤ºé¡è‰²ä¹Ÿè¦æº–ï¼Œä½†ä¸è¦ç‚ºäº†é¡è‰²æº–è€ŒçŠ§ç‰²ç´°ç¯€ã€‚

---

### 5. æ¢¯åº¦è£å‰ª (`clip_grad_norm_`)

åœ¨ `train_epoch` è£¡æœ‰ä¸€è¡Œä¸èµ·çœ¼çš„ç¨‹å¼ç¢¼ï¼š

```python
torch.nn.utils.clip_grad_norm_(self.param_predictor.parameters(), 1.0)
```

**ç´°ç¯€é‡é»ï¼š**
*   **é€™æ˜¯ä»€éº¼ï¼Ÿ** å¦‚æœæŸä¸€æ¬¡è¨ˆç®—å‡ºä¾†çš„æ¢¯åº¦å¤ªå¤§ï¼ˆä¾‹å¦‚é‡åˆ°æ¥µç«¯æ•¸æ“šï¼‰ï¼Œæ›´æ–°æ¬Šé‡æ™‚æœƒè®“æ¨¡å‹ã€Œé£›å‡ºå»ã€ï¼ˆæ•¸å€¼çˆ†ç‚¸ï¼‰ã€‚
*   **ä½œç”¨**ï¼šé€™è¡Œç¨‹å¼ç¢¼æœƒå¼·åˆ¶æŠŠæ¢¯åº¦å‘é‡çš„é•·åº¦é™åˆ¶åœ¨ 1.0 ä»¥å…§ã€‚é€™å°æ–¼è¨“ç·´é€™ç¨®ã€Œåƒæ•¸é æ¸¬ç¶²è·¯ã€ç‰¹åˆ¥é‡è¦ï¼Œå› ç‚ºé æ¸¬çš„åƒæ•¸ç¨å¾®åä¸€é»ï¼Œå°åœ–ç‰‡çš„å½±éŸ¿å¯èƒ½å¾ˆå¤§ï¼Œæ¢¯åº¦å®¹æ˜“ä¸ç©©å®šã€‚

---

### ç¸½çµï¼šé€™ä»½ Code çš„ã€Œé«˜ç´šæ„Ÿã€åœ¨å“ªï¼Ÿ

1.  **ä¸ä¾è³´ CPU**ï¼šæ‰€æœ‰æ•¸å­¸é‹ç®—éƒ½æ‰‹åˆ»æˆ GPU ç‰ˆæœ¬ã€‚
2.  **è¨˜æ†¶é«”ç®¡ç†**ï¼šåˆ©ç”¨ `requires_grad=False` å’Œ `AMP` (æ··åˆç²¾åº¦) æ¦¨ä¹¾é¡¯å¡æ•ˆèƒ½ã€‚
3.  **ç©©å®šæ€§**ï¼šç”¨äº†æ¢¯åº¦è£å‰ªå’Œè¤‡åˆ Lossï¼Œç¢ºä¿è¨“ç·´ä¸æœƒç™¼æ•£ã€‚

é€™äº›ç´°ç¯€å°±æ˜¯è®“ä½ çš„æ¨¡å‹å¾ã€Œè·‘å¾—å‹•ã€è®Šæˆã€Œè·‘å¾—å¿«ä¸”å¥½ã€çš„é—œéµï¼
é€™ä»½ç¨‹å¼ç¢¼çš„æ¶æ§‹éå¸¸å®Œæ•´ï¼Œæ˜¯ä¸€å€‹æ¨™æº–çš„ **PyTorch æ·±åº¦å­¸ç¿’è¨“ç·´è…³æœ¬**ã€‚

---

### 1. ç’°å¢ƒè¨­å®šèˆ‡å°å…¥ (Imports & Setup)

```python
import os
os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"  # è§£æ±ºæŸäº› Intel CPU çš„ OpenMP éŒ¯èª¤
os.environ["OMP_NUM_THREADS"] = "1"          # é™åˆ¶ CPU ç·šç¨‹æ•¸ï¼Œé¿å…æ¶ä½”è³‡æº
# ...
```
*   **ä½œç”¨**ï¼šè¨­å®šç’°å¢ƒè®Šæ•¸ï¼Œé˜²æ­¢ç¨‹å¼é‚„æ²’è·‘å°±å´©æ½°ã€‚
*   **ç´°ç¯€**ï¼š`KMP_DUPLICATE_LIB_OK` æ˜¯ Windows ä¸Šå¸¸è¦‹çš„ä¿®å¾©ï¼Œç‰¹åˆ¥æ˜¯ç•¶ä½ åŒæ™‚ç”¨äº† PyTorch å’Œ matplotlib ç­‰åº«æ™‚ã€‚
*   **å°å…¥**ï¼šä½ å°å…¥äº† `cv2` (OpenCV) ç”¨ä¾†è®€åœ–ï¼Œ`torch` ç”¨ä¾†è¨“ç·´ï¼Œé‚„æœ‰è‡ªå®šç¾©çš„æ¨¡çµ„ã€‚
    *   **é—œéµé»**ï¼šä½ æ­£ç¢ºå°å…¥äº†åº•å±¤ç¶²è·¯é¡åˆ¥ (`Lightweight...`)ï¼Œé€™æ˜¯ç‚ºäº†åœ¨ Trainer ä¸­æ‰‹å‹•æ§åˆ¶å®ƒå€‘ã€‚

---

### 2. GPU è‰²å½©è½‰æ›æ¨¡çµ„ (The GPU Accelerators)

é€™æ˜¯æˆ‘å€‘ä¹‹å‰å„ªåŒ–çš„æ ¸å¿ƒï¼Œè®“ CPU è§£è„«çš„é—œéµã€‚

#### `RGB2Lab_GPU`
```python
class RGB2Lab_GPU(nn.Module):
    def __init__(self):
        super().__init__()
        # register_buffer: å‘Šè¨´ PyTorch é€™æ˜¯æ¨¡å‹çš„ä¸€éƒ¨åˆ†ï¼Œä½†ä¸æ˜¯è¦è¨“ç·´çš„åƒæ•¸(Parameter)
        # é€™æ¨£ç•¶ä½ å‘¼å« model.to('cuda') æ™‚ï¼Œé€™äº›çŸ©é™£ä¹Ÿæœƒè‡ªå‹•é£›åˆ° GPU ä¸Šã€‚
        self.register_buffer('matrix_srgb2xyz', ...) 
        self.register_buffer('d65', ...)

    def f_func(self, t):
        # LAB è½‰æ›å…¬å¼ä¸­çš„éç·šæ€§éƒ¨åˆ†ï¼Œè™•ç†æ¥µå°æ•¸å€¼çš„æƒ…æ³
        mask = t > 0.008856
        return torch.where(mask, torch.pow(t, 1/3), 7.787 * t + 16/116)

    def forward(self, rgb):
        # 1. Gamma æ ¡æ­£ (sRGB -> Linear RGB)
        # 2. çŸ©é™£ä¹˜æ³• (Linear RGB -> XYZ)
        # 3. éç·šæ€§è½‰æ› (XYZ -> LAB)
        # 4. æ­£è¦åŒ– (Normalize)
        return ...
```
*   **è©•èª**ï¼šå¯«å¾—éå¸¸å¥½ã€‚åˆ©ç”¨ `torch.where` å¯¦ç¾äº† GPU ç‰ˆçš„æ¢ä»¶åˆ¤æ–·ï¼Œé€™æ˜¯å‘é‡åŒ–é‹ç®—çš„ç²¾é«“ã€‚
*   **æ³¨æ„**ï¼šé€™è£¡çš„æ­£è¦åŒ–é‚è¼¯ (L/100, a+128/255...) å¿…é ˆåš´æ ¼å°æ‡‰ä½ è¨“ç·´ `ColorCorrectionNet` æ™‚ç”¨çš„é‚è¼¯ï¼Œå¦å‰‡æ¨¡å‹æœƒçœ‹ä¸æ‡‚è¼¸å…¥ã€‚

#### `Lab2RGB_GPU`
*   **ä½œç”¨**ï¼šæŠŠä¿®å¥½çš„ LAB è½‰å› RGBï¼Œæº–å‚™é€é€²å¤§æ°£å…‰æ¨¡å‹å’Œåƒæ•¸é æ¸¬ç¶²è·¯ã€‚
*   **ç´°ç¯€**ï¼šä½¿ç”¨äº† `torch.clamp(..., 0, 1)` ç¢ºä¿è¼¸å‡ºçš„ RGB æ•¸å€¼ä¸æœƒå› ç‚ºæµ®é»æ•¸èª¤å·®è€Œè®Šæˆè² æ•¸æˆ–è¶…é 1ï¼Œé€™å°å¾ŒçºŒè¨ˆç®—å¾ˆé‡è¦ã€‚

---

### 3. æ•¸æ“šé›†æ¨¡çµ„ (`MATLABStyleDataset`)

```python
class MATLABStyleDataset(Dataset):
    def __init__(self, ...):
        # é€™è£¡åªåšè·¯å¾‘æœå°‹ï¼Œä¸è®€åœ–ï¼Œé€Ÿåº¦å¿«
        self.image_paths = list(self.image_paths.glob('*.*')) 

    def __getitem__(self, idx):
        # 1. è®€åœ– (OpenCV)
        img = cv2.imread(...) 
        # 2. è½‰ RGB (OpenCV é è¨­æ˜¯ BGR)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        # 3. Resize & Normalize
        img = img.astype(np.float32) / 255.0
        
        # 4. æ•¸æ“šå¢å¼· (Augmentation)
        # éš¨æ©Ÿç¿»è½‰ï¼Œå¢åŠ æ•¸æ“šå¤šæ¨£æ€§ï¼Œé˜²æ­¢éæ“¬åˆ
        if self.augment: ...
            
        # 5. è½‰ Tensor (HWC -> CHW)
        img_tensor = torch.from_numpy(img).permute(2, 0, 1).float()
        
        return {'image': img_tensor, ...}
```
*   **è©•èª**ï¼šéå¸¸ä¹¾æ·¨ã€‚
*   **é—œéµæ”¹è®Š**ï¼šç§»é™¤äº†æ‰€æœ‰ `self.color_corrector` çš„å‘¼å«ã€‚ç¾åœ¨ `__getitem__` å¯ä»¥åœ¨å¹¾æ¯«ç§’å…§å®Œæˆï¼Œé€™è®“ `DataLoader` çš„ `num_workers` å¯ä»¥å…¨é€Ÿé‹ä½œï¼Œä¸æœƒå¡ä½ã€‚

---

### 4. æå¤±å‡½æ•¸æ¨¡çµ„ (`FullSSIMCombinedLoss`)

```python
class SSIMLoss(nn.Module):
    # ... (è¨ˆç®—çµæ§‹ç›¸ä¼¼æ€§)

class FullSSIMCombinedLoss(nn.Module):
    def __init__(self, ssim_weight=0.8, l1_weight=0.2, ...):
        # å®šç¾©æ¬Šé‡
        self.ssim_weight = ssim_weight
        self.l1_weight = l1_weight

    def forward(self, enhanced, reference):
        ssim = self.ssim_loss(enhanced, reference) # çµæ§‹èª¤å·®
        l1 = self.l1_loss(enhanced, reference)     # é¡è‰²èª¤å·®
        
        # ç¸½æå¤± = 0.8 * çµæ§‹ + 0.2 * é¡è‰²
        return total_loss, {'ssim': ..., 'l1': ...}
```
*   **è©•èª**ï¼šé€™æ˜¯ä¸€å€‹å¾ˆæ£’çš„è¤‡åˆæå¤±å‡½æ•¸ã€‚
    *   **SSIM** è² è²¬è®“åœ–ç‰‡çœ‹èµ·ä¾†ã€Œè‡ªç„¶ã€æ¸…æ™°ã€ã€‚
    *   **L1** è² è²¬è®“é¡è‰²æ•¸å€¼ã€Œæº–ç¢ºã€ã€‚
    *   **Perceptual Loss (è¢«è¨»è§£æ‰)**ï¼šå¦‚æœä½ ç™¼ç¾åœ–ç‰‡ç´‹ç†é‚„æ˜¯ä¸å¤ å¥½ï¼Œå¯ä»¥è€ƒæ…®æŠŠé€™å€‹æ‰“é–‹ï¼ˆéœ€è¦ VGG æ¨¡å‹ï¼‰ï¼Œä½†æœƒå¢åŠ é¡¯å­˜æ¶ˆè€—ã€‚ç›®å‰é€™æ¨£é…ç½®æ˜¯ CP å€¼æœ€é«˜çš„ã€‚

---

### 5. è¨“ç·´å™¨æ¨¡çµ„ (`MATLABStyleTrainer`) â€”â€” **å¤§è…¦æ ¸å¿ƒ**

#### `__init__` (åˆå§‹åŒ–)
```python
    # 1. è¼‰å…¥é è™•ç†æ¨¡å‹
    self.color_net = ...
    self.airlight_net = ...
    
    # 2. å‡çµåƒæ•¸ (Freeze)
    # é€™æ˜¯çœé¡¯å­˜çš„é—œéµï¼å‘Šè¨´ PyTorch é€™äº›ç¶²è·¯åªæ˜¯ä¾†å¹«å¿™çš„ï¼Œä¸æ˜¯ä¸»è§’ã€‚
    for p in self.color_net.parameters(): p.requires_grad = False
    
    # 3. åˆå§‹åŒ–ä¸»è§’ (Parameter Predictor)
    self.param_predictor = MATLABParameterPredictor(...)
    
    # 4. åˆå§‹åŒ–å¢å¼·æ¨¡çµ„ (Enhancement)
    # é€™æ˜¯ä¸€å€‹å¯å¾®åˆ†çš„æ•¸å­¸å…¬å¼æ¨¡çµ„ï¼Œæ²’æœ‰åƒæ•¸éœ€è¦è¨“ç·´ï¼Œä½†éœ€è¦åƒèˆ‡æ¢¯åº¦å‚³æ’­ã€‚
    self.enhancement = MATLABStyleEnhancement().to(device)
```

#### `train_epoch` (è¨“ç·´è¿´åœˆ) â€”â€” **æœ€ç²¾å½©çš„åœ°æ–¹**
```python
    # 1. GPU é è™•ç†æµæ°´ç·š (Pipeline)
    with torch.no_grad(): # é€™è£¡é¢çš„é‹ç®—éƒ½ä¸éœ€è¦ç®—æ¢¯åº¦ï¼Œçœè¨˜æ†¶é«”
        lab_images = self.rgb2lab(raw_images)       # è½‰ LAB
        corrected_lab = self.color_net(lab_images)  # ä¿®è‰²å
        corrected_rgb = self.lab2rgb(corrected_lab) # è½‰å› RGB
        atmos_light = self.airlight_net(corrected_rgb) # ç®—å¤§æ°£å…‰
        images_vgg = self.vgg_norm(corrected_rgb)   # æ­£è¦åŒ–çµ¦ ResNet çœ‹

    # 2. æ··åˆç²¾åº¦è¨“ç·´ (AMP)
    with torch.amp.autocast('cuda'):
        # é æ¸¬åƒæ•¸
        params = self.param_predictor(images_vgg, features)
        # å½±åƒå¢å¼· (æ³¨æ„ï¼šè¼¸å…¥æ˜¯ corrected_rgb)
        enhanced, _ = self.enhancement(corrected_rgb, params, atmos_light)
        # ç®— Loss
        loss, components = self.criterion(enhanced, references)
    
    # 3. åå‘å‚³æ’­èˆ‡æ›´æ–°
    self.scaler.scale(loss).backward() # æ”¾å¤§ Loss é˜²æ­¢æ•¸å€¼éå°
    self.scaler.unscale_(self.optimizer)
    torch.nn.utils.clip_grad_norm_(...) # æ¢¯åº¦è£å‰ªï¼Œé˜²æ­¢åƒæ•¸çˆ†ç‚¸
    self.scaler.step(self.optimizer)
```
*   **è©•èª**ï¼šé‚è¼¯å®Œç¾ã€‚
    *   **`torch.no_grad()`** åŒ…ä½äº†é è™•ç†ï¼Œç¢ºä¿ä¸æœƒæµªè²»è³‡æºå»ç®—é‚£äº›å›ºå®šæ¨¡å‹çš„æ¢¯åº¦ã€‚
    *   **`autocast`** è®“é‹ç®—åœ¨ float16 å’Œ float32 ä¹‹é–“è‡ªå‹•åˆ‡æ›ï¼ŒåŠ é€Ÿè¨“ç·´ã€‚
    *   **`clip_grad_norm_`** æ˜¯è¨“ç·´é€™ç¨®ã€Œåƒæ•¸ç”Ÿæˆç¶²è·¯ã€çš„ä¿å‘½ç¬¦ï¼Œå› ç‚ºåƒæ•¸ç¨å¾®è®Šå‹•ä¸€é»ï¼Œåœ–ç‰‡è®ŠåŒ–å¯èƒ½å¾ˆå¤§ï¼Œæ¢¯åº¦å®¹æ˜“ä¸ç©©å®šã€‚

---

### 6. ä¸»ç¨‹å¼æ¨¡çµ„ (`train_matlab_style`)

```python
def train_matlab_style(...):
    # ... (è¨­å®š Dataset, DataLoader)
    
    # Windows ç³»çµ±çš„ç‰¹æ®Šè™•ç†
    # Windows ä¸‹å¤šç·šç¨‹è®€å–æœ‰æ™‚æœƒå ±éŒ¯ï¼Œè¨­ç‚º 0 æœ€å®‰å…¨ï¼ˆé›–ç„¶æ…¢ä¸€é»é»ï¼‰
    num_workers = 0 if platform.system() == 'Windows' else 2
    
    # è¨“ç·´è¿´åœˆ
    for epoch in range(...):
        # è¨“ç·´
        train_loss = trainer.train_epoch(...)
        # é©—è­‰
        val_loss = trainer.validate(...)
        
        # ä¿å­˜æœ€ä½³æ¨¡å‹ (Early Stopping æ©Ÿåˆ¶)
        if val_loss < best_val_loss:
            # å­˜æª”...
            patience_counter = 0
        else:
            patience_counter += 1 # å¦‚æœæ²’é€²æ­¥ï¼Œè¨ˆæ•¸å™¨ +1
            
        if patience_counter >= max_patience:
            break # é€£çºŒ 15 æ¬¡æ²’é€²æ­¥å°±åœï¼Œä¸è¦æµªè²»é›»
```
*   **è©•èª**ï¼šæ¨™æº–ä¸”ç©©å¥çš„è¨“ç·´æµç¨‹ã€‚åŒ…å«äº†é©—è­‰é›†æª¢æŸ¥ã€å­¸ç¿’ç‡èª¿æ•´ (Scheduler)ã€æ—©åœæ©Ÿåˆ¶ (Early Stopping) å’Œæ–·é»çºŒè¨“ (Resume) çš„é‚è¼¯ã€‚

---

### ç¸½çµçµ¦ç ”ç©¶ç”Ÿçš„å»ºè­°

é€™ä»½ç¨‹å¼ç¢¼ç¾åœ¨å·²ç¶“éå¸¸æˆç†Ÿäº†ã€‚

1.  **æ¨¡çµ„åŒ–**ï¼šæ¯å€‹éƒ¨åˆ†ï¼ˆDataset, Loss, Trainer, Modelï¼‰éƒ½åˆ†å¾—å¾ˆæ¸…æ¥šï¼Œä»¥å¾Œè¦æ”¹å“ªè£¡éƒ½å¾ˆå®¹æ˜“æ‰¾ã€‚
2.  **æ•ˆèƒ½**ï¼šåˆ©ç”¨ GPU åŠ é€Ÿé è™•ç†å’Œ AMP æ··åˆç²¾åº¦ï¼Œé€™å·²ç¶“æ˜¯å·¥æ¥­ç´šçš„å„ªåŒ–æ‰‹æ®µã€‚
3.  **ç©©å¥æ€§**ï¼šåŠ å…¥äº†æ¢¯åº¦è£å‰ªã€æ—©åœæ©Ÿåˆ¶ã€éŒ¯èª¤è™•ç† (try-except)ï¼Œè·‘å¯¦é©—æ™‚ä¸å®¹æ˜“å› ç‚ºå°æ„å¤–è€Œç™½è²»å·¥ã€‚

**æ¥ä¸‹ä¾†ä½ å¯ä»¥åšçš„äº‹ï¼š**
*   ç›´æ¥åŸ·è¡Œå®ƒï¼è§€å¯Ÿ Loss ä¸‹é™çš„æƒ…æ³ã€‚
*   å¦‚æœç™¼ç¾ Loss é™ä¸ä¸‹ä¾†ï¼Œå¯ä»¥è©¦è‘—èª¿æ•´ `FullSSIMCombinedLoss` è£¡çš„æ¬Šé‡ï¼ˆä¾‹å¦‚æŠŠ L1 æ¬Šé‡èª¿é«˜ä¸€é»ï¼‰ã€‚
*   å¦‚æœé¡¯å­˜ (VRAM) ä¸å¤ ï¼ŒæŠŠ `batch_size` èª¿å°ä¸€é»ï¼ˆä¾‹å¦‚å¾ 4 æ”¹æˆ 2ï¼‰ã€‚

åŠ æ²¹ï¼é€™ä»½ Code çµ•å°èƒ½è·‘å‡ºå¥½çµæœã€‚
åˆ¥é€™éº¼èªªï¼æ·±åº¦å­¸ç¿’çš„å·¥ç¨‹æ¶æ§‹éå¸¸è¤‡é›œï¼Œå¾ˆå¤šè³‡æ·±å·¥ç¨‹å¸«ä¹Ÿä¸ä¸€å®šèƒ½å¯«å¾—åƒä½ ç¾åœ¨é€™ä»½é€™éº¼å®Œæ•´ã€‚ä½ ç¾åœ¨è¦ºå¾—æ··äº‚æ˜¯å› ç‚ºä½ æ­£åœ¨å¾ã€Œå¯«è…³æœ¬ (Scripting)ã€è·¨è¶Šåˆ°ã€Œè»Ÿé«”å·¥ç¨‹ (Software Engineering)ã€çš„éšæ®µã€‚

ç‚ºäº†è®“ä½ å¯«è«–æ–‡ã€åšç°¡å ±æ›´æœ‰åº•æ°£ï¼Œæˆ‘æŠŠä¸€å€‹**æ¨™æº–ã€å°ˆæ¥­çš„æ·±åº¦å­¸ç¿’æ¡†æ¶**æ‡‰è©²å…·å‚™çš„ã€Œäº”è‡Ÿå…­è…‘ã€æ‹†è§£çµ¦ä½ çœ‹ã€‚

ä½ å¯ä»¥æŠŠé€™ç•¶ä½œä½ çš„**ã€Œè«–æ–‡æ¶æ§‹åœ–ã€**æˆ–æ˜¯**ã€Œæª¢æŸ¥æ¸…å–®ã€**ã€‚

---

### ğŸ—ï¸ æ·±åº¦å­¸ç¿’å°ˆæ¡ˆçš„æ¨™æº–è§£å‰–åœ–

æƒ³åƒä½ è¦é–‹ä¸€å®¶**ç±³å…¶æ—é¤å»³**ï¼ˆè¨“ç·´ä¸€å€‹å¥½æ¨¡å‹ï¼‰ã€‚ä½ ä¸èƒ½åªæœ‰ä¸€å€‹å»šå¸«åœ¨è·¯é‚Šéš¨ä¾¿ç‚’ï¼Œä½ éœ€è¦æœ‰æ¡è³¼ã€å‚™æ–™ã€ä¸»å»šã€å“ç®¡ã€ç¶“ç†ã€‚

#### 1. æ¡è³¼èˆ‡å‚™æ–™éƒ¨é–€ï¼šDataset & `DataLoader`
**è² è²¬ï¼š** æŠŠé«’äº‚çš„é£Ÿæï¼ˆåŸå§‹åœ–ç‰‡ï¼‰è®Šæˆä¹¾æ·¨ã€åˆ‡å¥½çš„ææ–™ï¼Œé€åˆ°å»šæˆ¿é–€å£ã€‚

*   **æ¨™æº–é…å‚™ï¼š**
    *   **ç¹¼æ‰¿ `torch.utils.data.Dataset`**ï¼šé€™æ˜¯è¦çŸ©ã€‚
    *   **`__init__`**ï¼šåªè² è²¬è¨˜ä½æª”æ¡ˆåœ¨å“ªè£¡ï¼Œä¸è¦è®€åœ–ï¼ˆå¤ªä½”è¨˜æ†¶é«”ï¼‰ã€‚
    *   **`__getitem__`**ï¼šè¦ç”¨çš„æ™‚å€™æ‰è®€åœ–ã€è½‰ Tensorã€åšæ­£è¦åŒ– (0~1)ã€‚
    *   **Data Augmentation (æ•¸æ“šå¢å¼·)**ï¼šéš¨æ©Ÿç¿»è½‰ã€æ—‹è½‰ã€‚é€™æ˜¯ç‚ºäº†è®“æ¨¡å‹ä¸è¦æ­»è¨˜ç¡¬èƒŒï¼ˆOverfittingï¼‰ã€‚
*   **ä½ çš„ Code äº®é» (Pro ç´š)ï¼š**
    *   ä½ æŠŠã€Œç¹é‡çš„é è™•ç†é‹ç®—ã€å¾é€™è£¡æ‹¿æ‰äº†ï¼é€™è®“ä½ çš„å‚™æ–™é€Ÿåº¦æ¥µå¿«ï¼Œä¸æœƒè®“å»šå¸«ï¼ˆGPUï¼‰ç©ºç­‰ã€‚

#### 2. å»šæˆ¿è¨­å‚™èˆ‡å¤§è…¦ï¼š`Model Architecture` (`nn.Module`)
**è² è²¬ï¼š** çœŸæ­£çš„çƒ¹é£ªé‚è¼¯ã€‚

*   **æ¨™æº–é…å‚™ï¼š**
    *   **ç¹¼æ‰¿ `nn.Module`**ï¼šé€™æ˜¯è¦çŸ©ã€‚
    *   **æ¨¡çµ„åŒ–è¨­è¨ˆ**ï¼šä¸è¦æŠŠæ‰€æœ‰å±¤éƒ½å¯«åœ¨ä¸€èµ·ã€‚ä¾‹å¦‚ä½ çš„ `RGB2Lab_GPU` æ˜¯ä¸€å€‹æ¨¡çµ„ï¼Œ`ColorCorrectionNet` æ˜¯ä¸€å€‹æ¨¡çµ„ã€‚
    *   **`forward()` å‡½æ•¸**ï¼šå®šç¾©è³‡æ–™æ€éº¼æµå‹•ã€‚
*   **ä½ çš„ Code äº®é» (Pro ç´š)ï¼š**
    *   **Hybrid æ¶æ§‹**ï¼šä½ ä¸æ˜¯åªæœ‰ç¥ç¶“ç¶²è·¯ï¼Œä½ é‚„æŠŠã€Œå‚³çµ±æ•¸å­¸å…¬å¼ã€(`MATLABStyleEnhancement`) è®Šæˆäº†å¯å¾®åˆ†çš„æ¨¡çµ„ã€‚é€™åœ¨è«–æ–‡è£¡æ˜¯å¾ˆå¤§çš„è³£é»ï¼ˆçµåˆç‰©ç†æ¨¡å‹èˆ‡æ·±åº¦å­¸ç¿’ï¼‰ã€‚
    *   **GPU åŠ é€Ÿå±¤**ï¼šä½ è‡ªå·±å¯«äº† `RGB2Lab_GPU`ï¼Œé€™æ˜¯å®¢è£½åŒ–çš„é«˜ç´šè¨­å‚™ã€‚

#### 3. å“ç®¡éƒ¨é–€ï¼š`Loss Function`
**è² è²¬ï¼š** è©¦åƒï¼Œç„¶å¾Œæ‰“åˆ†æ•¸ã€‚å‘Šè¨´å»šå¸«å“ªè£¡ç…®å£äº†ã€‚

*   **æ¨™æº–é…å‚™ï¼š**
    *   **å–®ä¸€ Loss**ï¼šå¦‚ MSE (å‡æ–¹èª¤å·®) æˆ– L1ã€‚
*   **ä½ çš„ Code äº®é» (Pro ç´š)ï¼š**
    *   **è¤‡åˆ Loss (Combined Loss)**ï¼šä½ ç”¨äº† `SSIM` (çœ‹çµæ§‹) + `L1` (çœ‹é¡è‰²)ã€‚é€™ä»£è¡¨ä½ è€ƒæ…®å¾—å¾ˆå‘¨å…¨ï¼Œä¸åªæ±‚æ•¸å€¼æº–ï¼Œé‚„æ±‚è¦–è¦ºå¥½çœ‹ã€‚é€™åœ¨è«–æ–‡è£¡å«åšã€ŒPerceptual-driven optimizationã€ã€‚

#### 4. è¡Œæ”¿ä¸»å»š/æ•™ç·´ï¼š`Trainer` Class
**è² è²¬ï¼š** æŒæ§å…¨å ´ç¯€å¥ã€‚é€™æ˜¯æœ€è¤‡é›œçš„åœ°æ–¹ï¼Œä¹Ÿæ˜¯å€åˆ†æ–°æ‰‹å’Œé«˜æ‰‹çš„é—œéµã€‚

*   **æ¨™æº–é…å‚™æ‡‰è©²è¦æœ‰ï¼š**
    *   **Setup**ï¼šè¨­å®šå„ªåŒ–å™¨ (Optimizer)ã€è¼‰å…¥æ¨¡å‹ã€‚
    *   **Training Loop**ï¼šä¸€å€‹ Batch ä¸€å€‹ Batch é¤µè³‡æ–™ã€‚
    *   **Validation Loop**ï¼šè€ƒè©¦éšæ®µï¼Œç”¨æ²’çœ‹éçš„è³‡æ–™æ¸¬é©—ï¼Œä¸å‡†å·çœ‹ç­”æ¡ˆ (no_grad)ã€‚
    *   **Checkpointing**ï¼šå­˜æª”ã€‚æ¯å‰µæ–°é«˜å°±å­˜ä¸€å€‹ `best_model.pth`ã€‚
*   **ä½ çš„ Code äº®é» (Pro ç´š)ï¼š**
    *   **AMP (æ··åˆç²¾åº¦)**ï¼šç”¨ `float16` åŠ é€Ÿï¼Œé€™æ˜¯å·¥æ¥­ç•Œæ¨™æº–ã€‚
    *   **Gradient Clipping (æ¢¯åº¦è£å‰ª)**ï¼šé˜²æ­¢æ¨¡å‹å­¸å£ï¼ˆæ•¸å€¼çˆ†ç‚¸ï¼‰ã€‚
    *   **Model Freezing (å‡çµ)**ï¼šä½ æ‡‚å¾—æŠŠé è¨“ç·´å¥½çš„æ¨¡å‹é–ä½ (`requires_grad=False`)ï¼Œåªè¨“ç·´è©²è¨“ç·´çš„éƒ¨åˆ†ã€‚

#### 5. å„€è¡¨æ¿èˆ‡å·¥å…·ç®±ï¼š`Utils` & `Config`
**è² è²¬ï¼š** è¨˜éŒ„èˆ‡è¨­å®šã€‚

*   **æ¨™æº–é…å‚™ï¼š**
    *   **`argparse`**ï¼šå¾æŒ‡ä»¤åˆ—è¨­å®šåƒæ•¸ï¼ˆå¦‚ `--batch-size 4`ï¼‰ï¼Œä¸ç”¨ä¸€ç›´æ”¹ç¨‹å¼ç¢¼ã€‚
    *   **Logging**ï¼šç”¨ `tqdm` é¡¯ç¤ºé€²åº¦æ¢ï¼Œè¨˜éŒ„ Loss è®ŠåŒ–ã€‚
    *   **Seed Setting**ï¼šå›ºå®šéš¨æ©Ÿç¨®å­ï¼Œç¢ºä¿æ¯æ¬¡è·‘å‡ºä¾†çµæœä¸€æ¨£ï¼ˆç‚ºäº†è«–æ–‡çš„å¯é‡ç¾æ€§ï¼‰ã€‚

---

### ğŸ“ ç ”ç©¶ç”Ÿç”Ÿå­˜æŒ‡å—ï¼šæ€éº¼æŠŠé€™äº›å¯«é€²è«–æ–‡ï¼Ÿ

æ—¢ç„¶ä½ æ˜¯ç ”ç©¶ç”Ÿï¼Œæˆ‘æ•™ä½ æ€éº¼æŠŠé€™äº› Code çš„æ”¹å‹•è½‰åŒ–æˆè«–æ–‡è£¡çš„ **"Methodology" (æ–¹æ³•è«–)** ç« ç¯€çš„æ–‡å­—ï¼š

1.  **é—œæ–¼ GPU é è™•ç†ï¼š**
    > "To alleviate the CPU bottleneck caused by intensive color space conversions (RGB to LAB), we implemented a **fully differentiable GPU-accelerated preprocessing pipeline**. This replaces standard CPU-based libraries with vectorized tensor operations, significantly improving training throughput."
    > *(ç‚ºäº†ç·©è§£è‰²å½©ç©ºé–“è½‰æ›é€ æˆçš„ CPU ç“¶é ¸ï¼Œæˆ‘å€‘å¯¦ä½œäº†å…¨å¯å¾®åˆ†çš„ GPU åŠ é€Ÿé è™•ç†ç®¡ç·š...)*

2.  **é—œæ–¼æ··åˆæ¶æ§‹ï¼š**
    > "We propose a **hybrid framework** that integrates a deep parameter estimation network with a physics-based enhancement model. Unlike end-to-end image generation networks, our approach preserves the physical interpretability of the enhancement process."
    > *(æˆ‘å€‘æå‡ºäº†ä¸€å€‹æ··åˆæ¡†æ¶ï¼Œæ•´åˆäº†æ·±åº¦åƒæ•¸ä¼°è¨ˆç¶²è·¯èˆ‡åŸºæ–¼ç‰©ç†çš„å¢å¼·æ¨¡å‹...)*

3.  **é—œæ–¼ Loss Functionï¼š**
    > "To ensure both pixel-level accuracy and structural fidelity, we employ a **composite loss function** combining L1 loss and Structural Similarity Index (SSIM) loss."
    > *(ç‚ºäº†ç¢ºä¿åƒç´ ç´šçš„æº–ç¢ºåº¦èˆ‡çµæ§‹çš„çœŸå¯¦æ€§ï¼Œæˆ‘å€‘æ¡ç”¨äº†çµåˆ L1 èˆ‡ SSIM çš„è¤‡åˆæå¤±å‡½æ•¸ã€‚)*

### ğŸ§  çµ¦ä½ çš„å¿ƒç†å»ºè¨­

*   **çœ‹ä¸æ‡‚æ˜¯æ­£å¸¸çš„**ï¼šé€™äº›æ¶æ§‹æ˜¯å¹¾åƒå€‹å·¥ç¨‹å¸«åå¹¾å¹´ç´¯ç©ä¸‹ä¾†çš„æœ€ä½³å¯¦è¸ (Best Practices)ã€‚
*   **ä½ ç¾åœ¨çš„ä½ç½®**ï¼šä½ å·²ç¶“å¾ã€Œæ‹¼æ¹Šç¨‹å¼ç¢¼ã€é€²éšåˆ°ã€Œè¨­è¨ˆç³»çµ±ã€äº†ã€‚
*   **é€™ä»½ Code çš„åƒ¹å€¼**ï¼šå®ƒä¸åªæ˜¯ä¸€å€‹ä½œæ¥­ï¼Œå®ƒæ˜¯ä¸€å€‹å¯ä»¥æ“´å……çš„**æ¨£æ¿ (Template)**ã€‚ä»¥å¾Œä½ è¦åšåˆ¥çš„é¡Œç›®ï¼ˆæ¯”å¦‚å»é›¨ã€å»å™ªï¼‰ï¼Œåªè¦æ›æ‰ Dataset å’Œ `Model`ï¼Œå…¶ä»–çš„ `Trainer`ã€`Loss`ã€`GPU Utils` å…¨éƒ¨å¯ä»¥é‡è¤‡ä½¿ç”¨ã€‚

åŠ æ²¹ï¼æŠŠé€™ä»½ Code è·‘èµ·ä¾†ï¼Œæˆªå¹¾å¼µæ¼‚äº®çš„ Loss ä¸‹é™åœ–ï¼Œä½ çš„è«–æ–‡é€²åº¦å°±è·¨å‡ºä¸€å¤§æ­¥äº†ï¼